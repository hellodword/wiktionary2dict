import operator
import os
import sys
from .writemdict.writemdict import MDictWriter as MDictWriterStream

from html import escape
from collections import defaultdict
from wikitextparser import WikiText
from xml.dom.minidom import Element
from xml.dom import pulldom
from typing import Callable, Tuple
import bz2


class BZ2OrXml(object):
    def __init__(self, filename):
        if filename.endswith('.bz2'):
            self.file = bz2.BZ2File(filename)
        else:
            self.file = open(filename)

    def __enter__(self):
        return self.file

    def __exit__(self, ctx_type, ctx_value, ctx_traceback):
        self.file.close()


def getElementTextByTagName(node: Element, name: str) -> str | None:
    elements = node.getElementsByTagName(name)
    if elements.length == 0:
        return None
    if not elements[0].hasChildNodes():
        return None
    return elements[0].firstChild.wholeText


def parse_wiktionary(
    path: str,
    word_cb: Callable[[str, WikiText, str, str], any] = None,
    template_cb: Callable[[str, WikiText, str, str], any] = None,
):

    def template_handle(title: str, text: str, redirect: str):
        if template_cb is None:
            return

        if title is None or title == '':
            return None

        if redirect is not None:
            return template_cb(title, None, None, redirect)

        if text is None:
            return None

        w = WikiText(text)
        if w is None:
            return None
        template_cb(title, w, text, None)

    def word_handle(title: str, text: str, redirect: str):
        if word_cb is None:
            return

        if title is None or title == '':
            return None

        if redirect is not None:
            return word_cb(title, None, None, redirect)

        if text is None:
            return None

        w = WikiText(text)
        if w is None:
            return None
        word_cb(title, w, text, None)

    def page_handle(node: Element) -> Tuple[str | None, str | None, str | WikiText | None]:
        redirect = None
        redirects = node.getElementsByTagName('redirect')
        if redirects.length > 0:
            redirect = redirects[0].getAttribute('title')

        ns = getElementTextByTagName(node, 'ns')
        if ns is None:
            return

        title = getElementTextByTagName(node, 'title')
        if title is None or title == '':
            return

        if ns == '0':
            model = getElementTextByTagName(node, 'model')
            if model == 'wikitext':
                return word_handle(
                    title,
                    getElementTextByTagName(node, 'text'),
                    redirect,
                )
        elif ns == '10':
            return template_handle(
                title,
                getElementTextByTagName(node, 'text'),
                redirect,
            )
        elif ns == '8':
            # TODO MediaWiki
            return
        elif ns == '14':
            # TODO Category
            return
        elif ns == '100':
            # TODO Appendix
            return
        else:
            # TODO
            return

        return

    with BZ2OrXml(path) as f:
        events = pulldom.parse(f)

        for (event, node) in events:
            if event == pulldom.START_ELEMENT:
                if node.tagName == 'page':
                    events.expandNode(node)
                    page_handle(node)


def mergeFiles(out: str, ins: list):
    BLOCKSIZE = 4096
    BLOCKS = 1024
    chunk = BLOCKS * BLOCKSIZE
    with open(out, "wb") as o:
        for fname in ins:
            with open(fname, "rb") as i:
                b = i.read(chunk)
                while len(b) > 0:
                    o.write(b)
                    b = i.read(chunk)


class Wiktionary2Dict:

    @staticmethod
    def run():

        if len(sys.argv) != 4:
            dump_path = 'data/en.sample.xml.bz2'
            dict_title = 'Wiktionary English'
            dict_file = 'data/sample.mdx'
        else:
            dump_path = sys.argv[1]
            dict_title = sys.argv[2]
            dict_file = sys.argv[3]

        assert (dict_file != '')
        assert (dict_title != '')
        assert (os.path.isfile(dump_path))
        assert (dump_path.endswith('.xml') or dump_path.endswith('.bz2'))

        with open(f'{dict_file}.1', 'wb') as output_header, open(f'{dict_file}.2', 'wb') as output_2, open(f'{dict_file}.3', 'wb') as output_key_block_body_body, open(f'{dict_file}.4', 'wb') as output_4, open(f'{dict_file}.5', 'wb') as output_record_block_body_body,  open(f'{dict_file}.record_temp', 'wb+') as output_record_temp:
            ws = MDictWriterStream(
                title=dict_title,
                description="Generated by https://github.com/hellodword/wiktionary2dict",
                output_key_block_body_body=output_key_block_body_body,
                output_record_block_body_body=output_record_block_body_body,
                is_mdd=False,
            )

            record_offset = 0
            items = []

            # for example
            def gen_html(w: WikiText) -> str:
                h = ''
                sections2 = w.get_sections(include_subsections=True, level=2)
                for s2 in sections2:
                    h += f'<h2>{escape(s2.title)}</h2>'
                    sections3 = s2.get_sections(include_subsections=False, level=3)
                    for s3 in sections3:
                        h += f'<h3>{escape(s3.title)}</h3>'
                return h

            def template_cb(title: str, w: WikiText, text: str, redirect: str):
                return

            def word_cb(title: str, w: WikiText, text: str, redirect: str):
                if redirect is not None:
                    record = f'@@@LINK={escape(redirect)}'.encode()
                else:
                    record = gen_html(w).encode()

                nonlocal record_offset
                record_len = len(record)
                items.append((escape(title), [record_offset, record_len]))
                record_offset = record_offset+record_len

                assert (output_record_temp.write(record) == record_len)

            parse_wiktionary(dump_path, word_cb=word_cb, template_cb=None)

            output_record_temp.seek(0, 0)

            items.sort(key=operator.itemgetter(0))

            for key, offset in items:
                # TODO calculate seek
                output_record_temp.seek(0, 0)
                output_record_temp.seek(offset[0], 0)

                record = output_record_temp.read(offset[1])
                assert (len(record) == offset[1])
                ws.add({key: record.decode()})

            ws.commit()
            ws.write_1_header(output_header)
            ws.write_2_key_preamble_and_index_and_block_body_header(output_2)
            ws.write_4_record_preamble_and_block_body_header(output_4)

        mergeFiles(f'{dict_file}',
                   [
                       f'{dict_file}.1',
                       f'{dict_file}.2',
                       f'{dict_file}.3',
                       f'{dict_file}.4',
                       f'{dict_file}.5',
                   ])
